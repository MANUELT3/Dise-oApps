import _extends from '@babel/runtime/helpers/esm/extends';
import * as React from 'react';
import { StyleSheet, Modal, View, ActivityIndicator } from 'react-native';
import WebView from 'react-native-webview';
import useLatestCallback from 'use-latest-callback';

let GoogleRecaptchaTheme;
(function (GoogleRecaptchaTheme) {
  GoogleRecaptchaTheme["DARK"] = "dark";
  GoogleRecaptchaTheme["LIGHT"] = "light";
})(GoogleRecaptchaTheme || (GoogleRecaptchaTheme = {}));
let GoogleRecaptchaSize;
(function (GoogleRecaptchaSize) {
  GoogleRecaptchaSize["NORMAL"] = "normal";
  GoogleRecaptchaSize["COMPACT"] = "compact";
  GoogleRecaptchaSize["INVISIBLE"] = "invisible";
})(GoogleRecaptchaSize || (GoogleRecaptchaSize = {}));
let GoogleRecaptchaActionName;
(function (GoogleRecaptchaActionName) {
  GoogleRecaptchaActionName["LOGIN"] = "LOGIN";
  GoogleRecaptchaActionName["PASSWORD_RESET"] = "PASSWORD_RESET";
  GoogleRecaptchaActionName["ADD_TO_CART"] = "ADD_TO_CART";
  GoogleRecaptchaActionName["CHECKOUT"] = "CHECKOUT";
  GoogleRecaptchaActionName["GET_PRICE"] = "GET_PRICE";
  GoogleRecaptchaActionName["PLAY_SONG"] = "PLAY_SONG";
})(GoogleRecaptchaActionName || (GoogleRecaptchaActionName = {}));
const DEFAULT_GSTATIC_DOMAIN = 'www.gstatic.com';
const DEFAULT_RECAPTCHA_DOMAIN = 'www.google.com';

const SITE_KEY_PATTERN = /^6[a-zA-Z0-9-_]{39}$/;
const LANG_PATTERN = /^([a-z]{2})(-(?!UK)[A-Z0-9]{2,3})?$/;
const DOMAIN_PATTERN = /^([a-z0-9-_]+\.)+([a-z0-9]{2,})(:[0-9]{2,})?$/i;
function getRecaptchaTemplate(props) {
  const {
    lang = 'en',
    siteKey,
    size = GoogleRecaptchaSize.NORMAL,
    theme = GoogleRecaptchaTheme.LIGHT,
    action = '',
    hideBadge = false,
    enterprise = false,
    gstaticDomain = DEFAULT_GSTATIC_DOMAIN,
    recaptchaDomain = DEFAULT_RECAPTCHA_DOMAIN
  } = props;
  let htmlLang = lang;
  const langMatches = LANG_PATTERN.exec(lang);
  if (!langMatches || langMatches.length < 2) {
    throw new TypeError(`Invalid lang value. Validity pattern: ${LANG_PATTERN}`);
  }
  htmlLang = langMatches[1];
  if (!SITE_KEY_PATTERN.test(siteKey)) {
    throw new TypeError(`Invalid siteKey value. Validity pattern: ${SITE_KEY_PATTERN}`);
  }
  if (!DOMAIN_PATTERN.test(gstaticDomain)) {
    throw new TypeError(`Invalid gstaticDomain value. Validity pattern: ${DOMAIN_PATTERN}`);
  }
  if (!DOMAIN_PATTERN.test(recaptchaDomain)) {
    throw new TypeError(`Invalid recaptchaDomain value. Validity pattern: ${DOMAIN_PATTERN}`);
  }
  const grecaptcha = enterprise ? 'window.grecaptcha.enterprise' : 'window.grecaptcha';
  const scriptUrl = enterprise ? `https://${recaptchaDomain}/recaptcha/enterprise.js?hl=${lang}` : `https://${recaptchaDomain}/recaptcha/api.js?hl=${lang}`;
  const jsScript = `<script src="${scriptUrl}" async defer></script>`;
  return `
    <!DOCTYPE html>
    <html lang="${htmlLang}">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title></title>
        <link rel="preconnect" href="https://${recaptchaDomain}">
        <link rel="preconnect" href="https://${gstaticDomain}" crossorigin>
        ${jsScript}
        <script>
            const siteKey = '${siteKey}';
            const theme = '${theme}';
            const size = '${size}';
            const action = '${action}';

            let readyInterval;
            let onCloseInterval;
            let widget;
            let onCloseObserver;

            const onClose = () => {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    close: []
                }));
            }

            const onLoad = () => {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    load: []
                }));
            }

            const onExpire = () => {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    expire: []
                }));
            }

            const onError = (error) => {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    error: [error]
                }));
            }

            const onVerify = (token) => {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    verify: [token]
                }));
            }

            const isReady = () => Boolean(typeof window === 'object' && window.grecaptcha && ${grecaptcha}.render);

            const registerOnCloseListener = () => {
                if (onCloseObserver) {
                    onCloseObserver.disconnect();
                }

                const iframes = document.getElementsByTagName('iframe');

                const recaptchaFrame = Array.prototype.find
                    .call(iframes, e => e.src.includes('google.com/recaptcha/api2/bframe'));
                const recaptchaElement = recaptchaFrame.parentNode.parentNode;

                clearInterval(onCloseInterval);

                let lastOpacity = recaptchaElement.style.opacity;
                onCloseObserver = new MutationObserver(mutations => {
                    if (lastOpacity !== recaptchaElement.style.opacity
                        && recaptchaElement.style.opacity == 0) {
                        onClose();
                    }
                    lastOpacity = recaptchaElement.style.opacity;
                });
                onCloseObserver.observe(recaptchaElement, {
                    attributes: true,
                    attributeFilter: ['style'],
                });
            }

            const isRendered = () => {
                return typeof widget === 'number';
            }

            const renderRecaptcha = () => {
                const recaptchaParams = {
                    sitekey: siteKey,
                    size,
                    theme,
                    callback: onVerify,
                    'error-callback': onError,
                    'expired-callback': onExpire,
                }
                if (action) {
                    recaptchaParams.action = action;
                }
                widget = ${grecaptcha}.render('recaptcha-container', recaptchaParams);
                if (onLoad) {
                    onLoad();
                }
                onCloseInterval = setInterval(registerOnCloseListener, 1000);
            }

            const updateReadyState = () => {
                if (isReady()) {
                    clearInterval(readyInterval);
                    renderRecaptcha()
                }
            }

            if (isReady()) {
                renderRecaptcha();
            } else {
                readyInterval = setInterval(updateReadyState, 1000);
            }

            window.rnRecaptcha = {
                execute: () => {
                    ${grecaptcha}.execute(widget);
                },
                reset: () => {
                    ${grecaptcha}.reset(widget);
                },
            }
        </script>

        <style>
            html,
            body,
            .container {
                height: 100%;
                width: 100%;
                margin: 0;
                padding: 0;
                background-color: transparent;
            }

            .container {
                display: flex;
                justify-content: center;
                align-items: center;
            }
            ${hideBadge ? '.grecaptcha-badge { visibility: hidden; }' : ''}
        </style>
    </head>

    <body>
      <div class="container">
        <span id="recaptcha-container"></span>
      </div>
    </body>
</html>`.trim();
}

const ORIGIN_WHITELIST = ['*'];
const BASE_URL_PATTERN = /^http(s)?:\/\/(\w+:?\w*)?(\S+)(:\d+)?(\/|\/([\w#!:.?+=&%\-\/]))?$/;
const GoogleRecaptcha = /*#__PURE__*/React.forwardRef((props, ref) => {
  const {
    theme,
    size,
    lang,
    action,
    baseUrl,
    siteKey,
    onLoad,
    onClose,
    onError,
    onVerify,
    onExpire,
    hideBadge,
    enterprise,
    modalProps,
    webViewProps = {},
    gstaticDomain,
    headerComponent,
    recaptchaDomain,
    footerComponent,
    loadingComponent,
    closeOnExpire = false
  } = props;
  const webViewRef = React.useRef(null);
  const isClosedRef = React.useRef(true);
  const [visible, setVisible] = React.useState(false);
  const [loading, setLoading] = React.useState(true);
  const tokenRef = React.useRef();
  const invisible = size === GoogleRecaptchaSize.INVISIBLE;
  const {
    style: webViewStyle,
    ...webViewOtherProps
  } = webViewProps;
  if (!BASE_URL_PATTERN.test(baseUrl)) {
    throw new TypeError('Invalid baseUrl value. baseUrl must be url.');
  }
  const html = React.useMemo(() => {
    return getRecaptchaTemplate({
      siteKey,
      size,
      theme,
      lang,
      action,
      hideBadge,
      enterprise,
      gstaticDomain,
      recaptchaDomain
    });
  }, [size, theme, lang, action, siteKey, hideBadge, enterprise, gstaticDomain, recaptchaDomain]);
  React.useEffect(() => {
    return () => {
      tokenRef.current = null;
    };
  }, []);
  const openModal = useLatestCallback(() => {
    setVisible(true);
    setLoading(true);
    isClosedRef.current = false;
  });
  const closeModal = useLatestCallback(() => {
    if (isClosedRef.current) {
      return;
    }
    isClosedRef.current = true;
    setVisible(false);
    onClose?.();
  });
  const getToken = useLatestCallback(() => {
    openModal();
    return new Promise((resolve, reject) => {
      tokenRef.current = {
        resolve,
        reject
      };
    });
  });
  React.useImperativeHandle(ref, () => ({
    open: openModal,
    close: closeModal,
    getToken: getToken
  }), [openModal, closeModal, getToken]);
  const handleLoad = useLatestCallback(() => {
    const webview = webViewRef.current;
    onLoad?.();
    if (webview && invisible) {
      webview.injectJavaScript('window.rnRecaptcha.execute();');
    }
    setLoading(false);
  });
  const handleMessage = useLatestCallback(event => {
    try {
      const payload = JSON.parse(event.nativeEvent.data);
      if (payload.close && invisible) {
        closeModal();
      }
      if (payload.load) {
        handleLoad();
      }
      if (payload.expire) {
        onExpire?.();
        if (closeOnExpire) {
          closeModal();
        }
      }
      if (payload.error) {
        const error = payload.error?.[0];
        onError?.(error);
        tokenRef.current?.reject?.(error);
        closeModal();
      }
      if (payload.verify) {
        const token = payload.verify?.[0];
        onVerify?.(token);
        tokenRef.current?.resolve?.(token);
        closeModal();
      }
    } catch (err) {
      onError?.(err);
      tokenRef.current?.reject?.(err);
    }
  });
  const source = React.useMemo(() => ({
    html,
    baseUrl
  }), [html, baseUrl]);
  const handleNavigationStateChange = useLatestCallback(() => {
    const webview = webViewRef.current;

    // prevent navigation on Android
    if (!loading && webview) {
      webview.stopLoading();
    }
  });
  const handleShouldStartLoadWithRequest = useLatestCallback(event => {
    // prevent navigation on iOS
    return event.navigationType === 'other';
  });
  const webViewStyles = React.useMemo(() => [styles.webView, webViewStyle], [webViewStyle]);
  return /*#__PURE__*/React.createElement(Modal, _extends({
    transparent: true
  }, modalProps, {
    visible: visible,
    onRequestClose: closeModal
  }), headerComponent, /*#__PURE__*/React.createElement(WebView, _extends({
    ref: webViewRef,
    bounces: false,
    originWhitelist: ORIGIN_WHITELIST,
    allowsBackForwardNavigationGestures: false
  }, webViewOtherProps, {
    source: source,
    style: webViewStyles,
    onMessage: handleMessage,
    onNavigationStateChange: handleNavigationStateChange,
    onShouldStartLoadWithRequest: handleShouldStartLoadWithRequest
  })), footerComponent, loading && /*#__PURE__*/React.createElement(View, {
    style: styles.loadingContainer
  }, loadingComponent || /*#__PURE__*/React.createElement(ActivityIndicator, {
    size: "large"
  })));
});
const styles = StyleSheet.create({
  webView: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)'
  },
  loadingContainer: {
    ...StyleSheet.absoluteFillObject,
    alignItems: 'center',
    justifyContent: 'center'
  }
});

export { DEFAULT_GSTATIC_DOMAIN, DEFAULT_RECAPTCHA_DOMAIN, GoogleRecaptchaActionName, GoogleRecaptchaSize, GoogleRecaptchaTheme, GoogleRecaptcha as default };
